df <- train_dat
#calculate theta-hats
X <- df %>%
mutate(trt = 1) %>%
dplyr::select(trt, age) %>%
as.matrix() #X (same as Z in this model)
mean_theta <- X %*% beta #theta-hat
vcov_theta <- X %*% var_beta %*% t(X) + X %*% var_rand %*% t(X)
var_theta <- diag(vcov_theta) #Var(theta-hat)
mean_theta
var_theta
head(mean_theta)
head(c(mean_theta))
mean_theta2 <- X %*% beta %>% c() #theta-hat
head(mean_theta)
head(mean_theta2)
all.equal(mean_theta, mean_theta2)
View(cbind(mean_theta, mean_theta2))
d <- cbind(mean_theta, mean_theta2)
sum(d$V1 == d$mean_theta2)
d <- data.frame(d)
head(d)
sum(d$V1==d$mean_theta2)
nrow(d)
nrow(train_dat)
mean_theta <- X %*% beta %>% c() #theta-hat
vcov_theta <- X %*% var_beta %*% t(X) + X %*% var_rand %*% t(X)
var_theta <- diag(vcov_theta) #Var(theta-hat)
#prediction interval
pred_lower <- mean_theta + qt(.025, 4)*sqrt(vartheta)
pred_upper <- mean_theta - qt(.025, 4)*sqrt(vartheta)
pred_lower
manual_pi <- function(df, mod) {
#get variances
res <- matrix_var(mod)
beta <- res$beta
var_beta <- res$var_beta
var_rand <- res$var_rand
#calculate theta-hats
X <- df %>%
mutate(trt = 1) %>%
dplyr::select(trt, age) %>%
as.matrix() #X (same as Z in this model)
mean_theta <- X %*% beta %>% c() #theta-hat
vcov_theta <- X %*% var_beta %*% t(X) + X %*% var_rand %*% t(X)
var_theta <- diag(vcov_theta) #Var(theta-hat)
#prediction interval
pred_lower <- mean_theta + qt(.025, 4)*sqrt(vartheta)
pred_upper <- mean_theta - qt(.025, 4)*sqrt(vartheta)
df <- df %>%
mutate(lower = pred_lower,
mean = mean_theta,
upper = pred_upper)
return(df)
} #add pis to dataset
d <- manual_pi(train_dat,mod)
View(d)
x <- 53.674415
meantheta <- fixef(mod)["W"] + fixef(mod)["W:age"]*x
vartheta <- fc["W","W"] + x^2*fc["W:age","W:age"] +
2*x*fc["W","W:age"] + rc[which(rc$var1=="W" & is.na(rc$var2)==T),"vcov"] +
x^2*rc[which(rc$var1=="W:age" & is.na(rc$var2)==T),"vcov"] +
2*x*rc[which(rc$var1=="W" & rc$var2=="W:age"),"vcov"]
meantheta
meantheta-qt(.025, 4)*sqrt(vartheta)
meantheta+qt(.025, 4)*sqrt(vartheta)
manual_pi <- function(df, mod, K) {
#get variances
res <- matrix_var(mod)
beta <- res$beta
var_beta <- res$var_beta
var_rand <- res$var_rand
#calculate theta-hats
X <- df %>%
mutate(trt = 1) %>%
dplyr::select(trt, age) %>%
as.matrix() #X (same as Z in this model)
mean_theta <- X %*% beta %>% c() #theta-hat
vcov_theta <- X %*% var_beta %*% t(X) + X %*% var_rand %*% t(X)
var_theta <- diag(vcov_theta) #Var(theta-hat)
#prediction interval
pred_lower <- mean_theta + qt(.025, K-2)*sqrt(var_theta)
pred_upper <- mean_theta - qt(.025, K-2)*sqrt(var_theta)
df <- df %>%
mutate(lower = pred_lower,
mean = mean_theta,
upper = pred_upper)
return(df)
} #add pis to dataset
d <- manual_pi(train_dat,mod,6)
x=61.720146
meantheta <- fixef(mod)["W"] + fixef(mod)["W:age"]*x
vartheta <- fc["W","W"] + x^2*fc["W:age","W:age"] +
2*x*fc["W","W:age"] + rc[which(rc$var1=="W" & is.na(rc$var2)==T),"vcov"] +
x^2*rc[which(rc$var1=="W:age" & is.na(rc$var2)==T),"vcov"] +
2*x*rc[which(rc$var1=="W" & rc$var2=="W:age"),"vcov"]
meantheta
meantheta + qt(.025, 6-2)*sqrt(vartheta)
meantheta - qt(.025, 6-2)*sqrt(vartheta)
source("R/MDD_Generation_OOSEst.R")
#simulate data ####
sim_dat <- gen_mdd(K=6, n_mean=200, n_sd=0, eps_study_m=1, eps_study_tau=0.05,
distribution="same", target_dist="same")
train_dat <- sim_dat[["train_dat"]]
target_dat <- sim_dat[["target_dat"]]
covars <- c("sex", "smstat", "weight", "age", "madrs")
#model ####
mod <- lmer(Y ~ W + age + W:age +
(W + age + W:age | S), data=train_dat)
sum <- summary(mod)
sum
# PI calculation by hand ####
matrix_var <- function(mod) {
#calculate variances
fc <- vcov(mod) #covariance matrix of fixed effects
rc <- as.data.frame(VarCorr(mod)) #variance and covariances of random effects
#matrix calculation
beta <- matrix(fixef(mod)[c("W","W:age")], nrow=2) #beta-hat
var_beta <- fc[c("W","W:age"),c("W","W:age")] #Var(beta-hat)
rand <- rc[c(which(rc$var1=="W" & is.na(rc$var2)==T),
which(rc$var1=="W" & rc$var2=="W:age"),
which(rc$var1=="W" & rc$var2=="W:age"),
which(rc$var1=="W:age" & is.na(rc$var2)==T)), "vcov"] #can I clean this up??
var_rand <- matrix(rcov, nrow=2, dimnames=list(c("W","W:age"),c("W","W:age"))) #Var(ranef)
return(list(beta=beta, var_beta=var_beta, var_rand=var_rand))
} #get variance components of model
manual_pi <- function(df, mod, K) {
#get variances
res <- matrix_var(mod)
beta <- res$beta
var_beta <- res$var_beta
var_rand <- res$var_rand
#calculate theta-hats
X <- df %>%
mutate(trt = 1) %>%
dplyr::select(trt, age) %>%
as.matrix() #X (same as Z in this model)
mean_theta <- X %*% beta %>% c() #theta-hat
vcov_theta <- X %*% var_beta %*% t(X) + X %*% var_rand %*% t(X)
var_theta <- diag(vcov_theta) #Var(theta-hat)
#prediction interval
pred_lower <- mean_theta + qt(.025, K-2)*sqrt(var_theta)
pred_upper <- mean_theta - qt(.025, K-2)*sqrt(var_theta)
df <- df %>%
mutate(lower = pred_lower,
mean = mean_theta,
upper = pred_upper)
return(df)
} #add pis to dataset
#prediction interval by glht ####
age_ci <- function(x, mod) {
ci <- glht(mod, linfct=paste0("W +",x,"*W:age = 0"))
mean <- coef(ci) %>% as.numeric()
sd <- sqrt(vcov(ci)[1,1])
lower <- mean - 1.96*sd %>% as.numeric()
upper <- mean + 1.96*sd %>% as.numeric()
return(c(lower=lower, mean=mean, upper=upper))
} #get ci based on x=age (as a character)
glht_ci <- function(df, mod) {
ages <- as.character(df$age)
cis <- map_dfr(.x=ages, .f=age_ci, mod=mod)
df <- df %>%
bind_cols(cis)
return(df)
} #add cis to dataset
a <- manual_pi(train_dat,mod,6)
# PI calculation by hand ####
matrix_var <- function(mod) {
#calculate variances
fc <- vcov(mod) #covariance matrix of fixed effects
rc <- as.data.frame(VarCorr(mod)) #variance and covariances of random effects
#matrix calculation
beta <- matrix(fixef(mod)[c("W","W:age")], nrow=2) #beta-hat
var_beta <- fc[c("W","W:age"),c("W","W:age")] #Var(beta-hat)
rand <- rc[c(which(rc$var1=="W" & is.na(rc$var2)==T),
which(rc$var1=="W" & rc$var2=="W:age"),
which(rc$var1=="W" & rc$var2=="W:age"),
which(rc$var1=="W:age" & is.na(rc$var2)==T)), "vcov"] #can I clean this up??
var_rand <- matrix(rand, nrow=2, dimnames=list(c("W","W:age"),c("W","W:age"))) #Var(ranef)
return(list(beta=beta, var_beta=var_beta, var_rand=var_rand))
} #get variance components of model
manual_pi <- function(df, mod, K) {
#get variances
res <- matrix_var(mod)
beta <- res$beta
var_beta <- res$var_beta
var_rand <- res$var_rand
#calculate theta-hats
X <- df %>%
mutate(trt = 1) %>%
dplyr::select(trt, age) %>%
as.matrix() #X (same as Z in this model)
mean_theta <- X %*% beta %>% c() #theta-hat
vcov_theta <- X %*% var_beta %*% t(X) + X %*% var_rand %*% t(X)
var_theta <- diag(vcov_theta) #Var(theta-hat)
#prediction interval
pred_lower <- mean_theta + qt(.025, K-2)*sqrt(var_theta)
pred_upper <- mean_theta - qt(.025, K-2)*sqrt(var_theta)
df <- df %>%
mutate(lower = pred_lower,
mean = mean_theta,
upper = pred_upper)
return(df)
} #add pis to dataset
a <- manual_pi(train_dat,mod,6)
View(a)
fixef(mod)["W"] + fixef(mod)["W:age"]*34.80091
x=34.8009134.80091
x=34.80091
fc <- vcov(mod)
rc <- as.data.frame(VarCorr(mod))
#example CATE PI ####
# example: let age be 40 years old
# x <- 40
# meantheta <- fixef(mod)["W"] + fixef(mod)["W:age"]*x
vartheta <- fc["W","W"] + x^2*fc["W:age","W:age"] +
2*x*fc["W","W:age"] + rc[which(rc$var1=="W" & is.na(rc$var2)==T),"vcov"] +
x^2*rc[which(rc$var1=="W:age" & is.na(rc$var2)==T),"vcov"] +
2*x*rc[which(rc$var1=="W" & rc$var2=="W:age"),"vcov"]
0.3755929 + qt(.025, 4)*sqrt(vartheta)
0.3755929 - qt(.025, 4)*sqrt(vartheta)
library(tidyverse)
library(rsample)
library(grf)
library(fastDummies)
library(nnet)
library(lme4)
library(pimeta)
library(multcomp)
library(merTools)
library(marginaleffects)
source("R/MDD_Generation_OOSEst.R")
#simulate data ####
sim_dat <- gen_mdd(K=6, n_mean=200, n_sd=0, eps_study_m=1, eps_study_tau=0.05,
distribution="same", target_dist="same")
train_dat <- sim_dat[["train_dat"]]
target_dat <- sim_dat[["target_dat"]]
covars <- c("sex", "smstat", "weight", "age", "madrs")
#model ####
mod <- lmer(Y ~ W + age + W:age +
(W + age + W:age | S), data=train_dat)
sum <- summary(mod)
sum
#prediction interval by hand ####
matrix_var <- function(mod) {
#calculate variances
fc <- vcov(mod) #covariance matrix of fixed effects
rc <- as.data.frame(VarCorr(mod)) #variance and covariances of random effects
#matrix calculation
beta <- matrix(fixef(mod)[c("W","W:age")], nrow=2) #beta-hat
var_beta <- fc[c("W","W:age"),c("W","W:age")] #Var(beta-hat)
rand <- rc[c(which(rc$var1=="W" & is.na(rc$var2)==T),
which(rc$var1=="W" & rc$var2=="W:age"),
which(rc$var1=="W" & rc$var2=="W:age"),
which(rc$var1=="W:age" & is.na(rc$var2)==T)), "vcov"] #can I clean this up??
var_rand <- matrix(rand, nrow=2, dimnames=list(c("W","W:age"),c("W","W:age"))) #Var(ranef)
return(list(beta=beta, var_beta=var_beta, var_rand=var_rand))
} #get variance components of model
manual_pi <- function(df, mod, K) {
#get variances
res <- matrix_var(mod)
beta <- res$beta
var_beta <- res$var_beta
var_rand <- res$var_rand
#calculate theta-hats
X <- df %>%
mutate(trt = 1) %>%
dplyr::select(trt, age) %>%
as.matrix() #X (same as Z in this model)
mean_theta <- X %*% beta %>% c() #theta-hat
vcov_theta <- X %*% var_beta %*% t(X) + X %*% var_rand %*% t(X)
var_theta <- diag(vcov_theta) #Var(theta-hat)
#prediction interval
pred_lower <- mean_theta + qt(.025, K-2)*sqrt(var_theta)
pred_upper <- mean_theta - qt(.025, K-2)*sqrt(var_theta)
df <- df %>%
mutate(lower = pred_lower,
mean = mean_theta,
upper = pred_upper)
return(df)
} #add pis to dataset
#confidence interval by glht ####
age_ci <- function(x, mod) {
ci <- glht(mod, linfct=paste0("W +",x,"*W:age = 0"))
mean <- coef(ci) %>% as.numeric()
sd <- sqrt(vcov(ci)[1,1])
lower <- mean - 1.96*sd %>% as.numeric()
upper <- mean + 1.96*sd %>% as.numeric()
return(c(lower=lower, mean=mean, upper=upper))
} #get ci based on x=age (as a character)
glht_ci <- function(df, mod) {
ages <- as.character(df$age)
cis <- map_dfr(.x=ages, .f=age_ci, mod=mod)
df <- df %>%
bind_cols(cis)
return(df)
} #add cis to dataset
x <- manual_pi(train_dat, mod, 6)
View(x)
#calculate mse
train_mse <- mean((train_dat$mean - train_dat$tau)^2)
train_mse
#calculate mse
train_mse <- mean((x$mean - x$tau)^2)
train_mse
train_coverage <- sum(x$tau >= x$lower & x$tau <= x$upper)/nrow(x)
train_coverage
#simulate data ####
sim_dat <- gen_mdd(K=6, n_mean=200, n_sd=0, eps_study_m=1, eps_study_tau=0.05,
distribution="same", target_dist="same")
train_dat <- sim_dat[["train_dat"]]
target_dat <- sim_dat[["target_dat"]]
covars <- c("sex", "smstat", "weight", "age", "madrs")
#model ####
mod <- lmer(Y ~ W + age + W:age +
(W + age + W:age | S), data=train_dat)
sum <- summary(mod)
ranef(mod)
rc <- as.data.frame(VarCorr(mod)) #variance and covariances of random effects
rc
rand <- rc[c(which(rc$var1=="W" & is.na(rc$var2)==T),
which(rc$var1=="W" & rc$var2=="W:age"),
which(rc$var1=="W" & rc$var2=="W:age"),
which(rc$var1=="W:age" & is.na(rc$var2)==T)), "vcov"] #can I clean this up??
rand
var_rand <- matrix(rand, nrow=2, dimnames=list(c("W","W:age"),c("W","W:age"))) #Var(ranef)
var_rand
ranef(mod, condVar=TRUE)
ranef(mod)
train_dat
#prediction interval by bootstrap ####
age <- train_dat$age[1]
age
summary(mod)
#prediction interval by hand ####
matrix_var <- function(mod) {
#calculate variances
fc <- vcov(mod) #covariance matrix of fixed effects
rc <- as.data.frame(VarCorr(mod)) #variance and covariances of random effects
#matrix calculation
beta <- matrix(fixef(mod)[c("W","W:age")], nrow=2) #beta-hat
var_beta <- fc[c("W","W:age"),c("W","W:age")] #Var(beta-hat)
rand <- rc[c(which(rc$var1=="W" & is.na(rc$var2)==T),
which(rc$var1=="W" & rc$var2=="W:age"),
which(rc$var1=="W" & rc$var2=="W:age"),
which(rc$var1=="W:age" & is.na(rc$var2)==T)), "vcov"] #can I clean this up??
var_rand <- matrix(rand, nrow=2, dimnames=list(c("W","W:age"),c("W","W:age"))) #Var(ranef)
return(list(beta=beta, var_beta=var_beta, var_rand=var_rand))
} #get variance components of model
matrix_var(mod)
res <- matrix_var(mod)
res
?lmer
ranef(mod)
colMeans(ranef(mod)$S)
?mvrnorm
library(MASS)
c(res$beta)
res
#bootstrap
boot_fix <- mvrnorm(n=1000, mu=c(res$beta), Sigma = res$var_beta)
boot_fix
cov(boot_fix)
res$var_beta
colMeans(boot_fix)
res$beta
res$var_rand
boot_rand <- mvnrorm(n=1000, mu=c(0,0), Sigma=res$var_rand)
boot_rand <- mvrnrorm(n=1000, mu=c(0,0), Sigma=res$var_rand)
boot_rand <- mvrnorm(n=1000, mu=c(0,0), Sigma=res$var_rand)
boot_rand
colMeans(boot_rand)
cov(boot_rand)
res$var_rand
res$var_beta
age
head(boot_fix)
head(boot_rand)
boot_fix$W
#randomly sample fixed and random coefficients
boot_fix <- mvrnorm(n=1000, mu=c(res$beta), Sigma=res$var_beta) %>%
data.frame()
head(boot_fix)
boot_fix$W.age
boot_rand <- mvrnorm(n=1000, mu=c(0,0), Sigma=res$var_rand) %>%
data.frame() #assume ranefs have mean 0
x=age
cates <- (boot_fix$W + boot_rand$W) +
(boot_fix$W.age + boot_rand$W.age)*x
cates
mean <- mean(cates)
mean
glht(mod, linfct=paste0("W +",x,"*W:age = 0"))
lower <- mean - 1.96*sd
upper <- mean + 1.96*sd
#calculate interval over all iterations
mean <- mean(cates)
sd <- sd(cates)
mean
sd
lower <- mean - 1.96*sd
upper <- mean + 1.96*sd
lower
upper
qt(.025, 6-2)
sample_cate <- function(x, boot_fix, boot_rand) {
#get cate|x according to each coefficient
cates <- (boot_fix$W + boot_rand$W) +
(boot_fix$W.age + boot_rand$W.age)*x
#calculate interval over all iterations
mean <- mean(cates)
sd <- sd(cates)
lower <- mean - 1.96*sd
upper <- mean + 1.96*sd
return(c(lower=lower, mean=mean, upper=upper))
}
#apply coefficients to estimate cate for all ages
train_intervals <- map_dfr(.x=train_dat$age, .f=sample_cate,
boot_fix=boot_fix, boot_rand=boot_rand)
train_intervals
#prediction interval by bootstrap ####
#create intervals from bootstrap
sample_cate <- function(x, boot_fix, boot_rand) {
#get cate|x according to each coefficient
cates <- (boot_fix$W + boot_rand$W) +
(boot_fix$W.age + boot_rand$W.age)*x
#calculate interval over all iterations
mean <- mean(cates)
sd <- sd(cates)
lower <- mean - 1.96*sd
upper <- mean + 1.96*sd
return(c(lower=lower, mean=mean, upper=upper))
}
#bootstrap and add intervals to data
boot_cate <- function(df, mod) {
#get var-covar of fixed and random effects from model
res <- matrix_var(mod)
#randomly sample fixed and random coefficients
boot_fix <- mvrnorm(n=1000, mu=c(res$beta), Sigma=res$var_beta) %>%
data.frame()
boot_rand <- mvrnorm(n=1000, mu=c(0,0), Sigma=res$var_rand) %>%
data.frame() #assume ranefs have mean 0
#apply coefficients to estimate cate for all ages
intervals <- map_dfr(.x=df$age, .f=sample_cate,
boot_fix=boot_fix, boot_rand=boot_rand)
df <- df %>%
bind_cols(intervals)
return(df)
}
a <- boot_cate(train_dat)
#get var-covar of fixed and random effects from model
res <- matrix_var(mod)
#randomly sample fixed and random coefficients
boot_fix <- mvrnorm(n=1000, mu=c(res$beta), Sigma=res$var_beta) %>%
data.frame()
boot_rand <- mvrnorm(n=1000, mu=c(0,0), Sigma=res$var_rand) %>%
data.frame() #assume ranefs have mean 0
#apply coefficients to estimate cate for all ages
intervals <- map_dfr(.x=df$age, .f=sample_cate,
boot_fix=boot_fix, boot_rand=boot_rand)
#apply coefficients to estimate cate for all ages
intervals <- map_dfr(.x=train_dat$age, .f=sample_cate,
boot_fix=boot_fix, boot_rand=boot_rand)
df <- df %>%
bind_cols(intervals)
#prediction interval by bootstrap ####
#create intervals from bootstrap
sample_cate <- function(x, boot_fix, boot_rand) {
#get cate|x according to each coefficient
cates <- (boot_fix$W + boot_rand$W) +
(boot_fix$W.age + boot_rand$W.age)*x
#calculate interval over all iterations
mean <- mean(cates)
sd <- sd(cates)
lower <- mean - 1.96*sd
upper <- mean + 1.96*sd
return(c(lower=lower, mean=mean, upper=upper))
}
sample_cate(40, boot_fix, boot_rand)
#bootstrap and add intervals to data
boot_cate <- function(df, mod) {
#get var-covar of fixed and random effects from model
res <- matrix_var(mod)
#randomly sample fixed and random coefficients
boot_fix <- mvrnorm(n=1000, mu=c(res$beta), Sigma=res$var_beta) %>%
data.frame()
boot_rand <- mvrnorm(n=1000, mu=c(0,0), Sigma=res$var_rand) %>%
data.frame() #assume ranefs have mean 0
#apply coefficients to estimate cate for all ages
intervals <- map_dfr(.x=df$age, .f=sample_cate,
boot_fix=boot_fix, boot_rand=boot_rand)
df <- df %>%
bind_cols(intervals)
return(df)
}
boot_cate(train_dat, mod) -> a
a
#calculate mse
train_mse <- mean((train_dat$mean - train_dat$tau)^2)
train_mse
train_dat <_ a
train_dat <- a
#calculate mse
train_mse <- mean((train_dat$mean - train_dat$tau)^2)
train_mse
#calculate coverage
train_coverage <- sum(train_dat$tau >= train_dat$lower & train_dat$tau <= train_dat$upper)/nrow(train_dat)
#calculate length
train_length <- mean(train_dat$upper - train_dat$lower)
seq(30,55,10)
?seq
seq(30,55,length.out=10)
