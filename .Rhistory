#calculate variances
fc <- vcov(mod) #covariance matrix of fixed effects
rc <- as.data.frame(VarCorr(mod)) #variance and covariances of random effects
#matrix calculation
beta <- matrix(fixef(mod)[c("W","W:age")], nrow=2) #beta-hat
var_beta <- fc[c("W","W:age"),c("W","W:age")] #Var(beta-hat)
rand <- rc[c(which(rc$var1=="W" & is.na(rc$var2)==T),
which(rc$var1=="W" & rc$var2=="W:age"),
which(rc$var1=="W" & rc$var2=="W:age"),
which(rc$var1=="W:age" & is.na(rc$var2)==T)), "vcov"] #can I clean this up??
var_rand <- matrix(rand, nrow=2, dimnames=list(c("W","W:age"),c("W","W:age"))) #Var(ranef)
return(list(beta=beta, var_beta=var_beta, var_rand=var_rand))
}
#add pis to dataset
manual_pi <- function(df, mod, K) {
#get variances
res <- matrix_var(mod)
beta <- res$beta
var_beta <- res$var_beta
var_rand <- res$var_rand
#calculate theta-hats
X <- df %>%
mutate(trt = 1) %>%
dplyr::select(trt, age) %>%
as.matrix() #X (same as Z in this model)
mean_theta <- X %*% beta %>% c() #theta-hat
vcov_theta <- X %*% var_beta %*% t(X) + X %*% var_rand %*% t(X)
var_theta <- diag(vcov_theta) #Var(theta-hat)
#prediction interval
pred_lower <- mean_theta + qt(.025, K-2)*sqrt(var_theta)
pred_upper <- mean_theta - qt(.025, K-2)*sqrt(var_theta)
df <- df %>%
mutate(lower = pred_lower,
mean = mean_theta,
upper = pred_upper)
return(df)
}
#confidence interval by glht ####
#get ci based on x=age (as a character)
age_ci <- function(x, mod) {
ci <- glht(mod, linfct=paste0("W +",x,"*W:age = 0"))
mean <- coef(ci) %>% as.numeric()
sd <- sqrt(vcov(ci)[1,1])
lower <- mean - 1.96*sd %>% as.numeric()
upper <- mean + 1.96*sd %>% as.numeric()
return(c(lower=lower, mean=mean, upper=upper))
}
#add cis to dataset
glht_ci <- function(df, mod) {
ages <- as.character(df$age)
cis <- map_dfr(.x=ages, .f=age_ci, mod=mod)
df <- df %>%
bind_cols(cis)
return(df)
}
#prediction interval by bootstrap ####
#create intervals from bootstrap
sample_cate <- function(x, boot_fix, boot_rand) {
#get cate|x according to each coefficient
cates <- (boot_fix$W + boot_rand$W) +
(boot_fix$W.age + boot_rand$W.age)*x
#calculate interval over all iterations
mean <- mean(cates)
sd <- sd(cates)
lower <- mean - 1.96*sd
upper <- mean + 1.96*sd
return(c(lower=lower, mean=mean, upper=upper))
}
#bootstrap and add intervals to data
boot_pi <- function(df, mod) {
#get var-covar of fixed and random effects from model
res <- matrix_var(mod)
#randomly sample fixed and random coefficients
boot_fix <- mvrnorm(n=1000, mu=c(res$beta), Sigma=res$var_beta) %>%
data.frame()
boot_rand <- mvrnorm(n=1000, mu=c(0,0), Sigma=res$var_rand) %>%
data.frame() #assume ranefs have mean 0
#apply coefficients to estimate cate for all ages
intervals <- map_dfr(.x=df$age, .f=sample_cate,
boot_fix=boot_fix, boot_rand=boot_rand)
df <- df %>%
bind_cols(intervals)
return(df)
}
#check results for all methods ####
assess_interval <- function(train_dat, target_dat) {
#calculate mse
train_mse <- mean((train_dat$mean - train_dat$tau)^2)
target_mse <- mean((target_dat$mean - target_dat$tau)^2)
#calculate coverage
train_coverage <- sum(train_dat$tau >= train_dat$lower & train_dat$tau <= train_dat$upper)/nrow(train_dat)
target_coverage <- sum(target_dat$tau >= target_dat$lower & target_dat$tau <= target_dat$upper)/nrow(target_dat)
#calculate length
train_length <- mean(train_dat$upper - train_dat$lower)
target_length <- mean(target_dat$upper - target_dat$lower)
return(c(train_mse = train_mse, target_mse = target_mse,
train_coverage = train_coverage, target_coverage = target_coverage,
train_length = train_length, target_length = target_length))
}
#overall function ####
compare_oos <- function(N=100, K=6, n_mean=200, n_sd=0, eps_study_m=0.05, eps_study_tau=3,
eps_study_age=0.05, distribution="same", target_dist="same", eps_target=0) {
## Simulate training and target (OOS) data
sim_dat <- gen_mdd(K, n_mean, n_sd, eps_study_m, eps_study_tau,
eps_study_age, distribution, target_dist, eps_target)
train_dat <- sim_dat[["train_dat"]]
target_dat <- sim_dat[["target_dat"]]
covars <- c("sex", "smstat", "weight", "age", "madrs")
## Fit mixed effects model
mod <- lmer(Y ~ age + madrs + sex + W + W:age +
(W + W:age | S), data=train_dat)
sum <- summary(mod)
## Calculate mean and CIs for individual and assess accuracy
#confidence interval
glht_train <- glht_ci(train_dat, mod)
glht_target <- glht_ci(target_dat, mod)
glht_res <- assess_interval(glht_train, glht_target)
#manual PI
manual_train <- manual_pi(train_dat, mod)
manual_target <- manual_pi(target_dat, mod)
manual_res <- assess_interval(manual_train, manual_target)
#bootstrap PI
boot_train <- boot_pi(train_dat, mod)
boot_target <- boot_pi(target_dat, mod)
boot_res <- assess_interval(boot_train, boot_target)
## Save results
return(list(sum=sum, glht_res=glht_res, manual_res=manual_res, boot_res=boot_res,
N=N, K=K, n_mean=n_mean, n_sd=n_sd,
eps_study_m=eps_study_m, eps_study_tau=eps_study_tau,
distribution=distribution, target_dist=target_dist))
}
N=100
K=6,
K=6
n_mean=200
n_sd=0
eps_study_m=0.05
eps_study_tau=
3
eps_study_age=0.05
distribution="same"
target_dist="same"
eps_target=0
## Simulate training and target (OOS) data
sim_dat <- gen_mdd(K, n_mean, n_sd, eps_study_m, eps_study_tau,
eps_study_age, distribution, target_dist, eps_target)
train_dat <- sim_dat[["train_dat"]]
train_dat <- sim_dat[["train_dat"]]
target_dat <- sim_dat[["target_dat"]]
View(train_dat)
View(target_dat)
## Fit mixed effects model
mod <- lmer(Y ~ age + madrs + sex + W + W:age +
(W + W:age | S), data=train_dat)
## Fit mixed effects model
mod <- lmer(Y ~ age + madrs + sex + W + W:age +
(W + W:age | S), data=train_dat,
control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=10000)))
sum <- summary(mod)
sum
## Calculate mean and CIs for individual and assess accuracy
#confidence interval
glht_train <- glht_ci(train_dat, mod)
df <- train_dat
ages <- as.character(df$age)
cis <- map_dfr(.x=ages, .f=age_ci, mod=mod)
## Fit mixed effects model
mod <- lmer(Y ~ age + madrs + sex + W + W:age +
(W + W:age | S), data=train_dat,
control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=10000)))
## Fit mixed effects model
mod <- lmer(Y ~ age + madrs + sex + W + W:age +
(W + W:age | S), data=train_dat)
summary(mod)
## Fit mixed effects model
mod <- lmer(Y ~  madrs + sex + W*age +
(W + W:age | S), data=train_dat,
control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=10000)))
sum <- summary(mod)
sum
## Calculate mean and CIs for individual and assess accuracy
#confidence interval
glht_train <- glht_ci(train_dat, mod)
View(glht_train)
glht_target <- glht_ci(target_dat, mod)
glht_res <- assess_interval(glht_train, glht_target)
glht_res
#manual PI
manual_train <- manual_pi(train_dat, mod)
#manual PI
manual_train <- manual_pi(train_dat, mod, K)
manual_target <- manual_pi(target_dat, mod, K)
manual_res <- assess_interval(manual_train, manual_target)
View(manual_train)
manual_res
#bootstrap PI
boot_train <- boot_pi(train_dat, mod)
boot_target <- boot_pi(target_dat, mod)
boot_res <- assess_interval(boot_train, boot_target)
boot_res
View(boot_train)
settings <- expand.grid(eps_combo = c("0.05 0.05 0.05", "0.05 1 0.05", "0.05 1 1",
"1 1 1", "1 3 1"),
distribution = c("same", "varying_madrs", "halfdiff_madrsage", "separate_age"),
target_dist = c("same", "upweight", "different"),
iteration = c(1:1000)) %>%
separate(eps_combo, into=c("eps_study_m", "eps_study_tau", "eps_study_age"), sep=" ") %>%
mutate(eps_study_m = as.numeric(eps_study_m),
eps_study_tau = as.numeric(eps_study_tau),
eps_study_age = as.numeric(eps_study_age))
head(settings)
#calculate variances
fc <- vcov(mod) #covariance matrix of fixed effects
rc <- as.data.frame(VarCorr(mod)) #variance and covariances of random effects
r
rc
which(rc$var1=="W" & is.na(rc$var2)==T)
rand <- rc[c(which(rc$var1=="W" & is.na(rc$var2)==T)), "vcov"] #can I clean this up??
rand
var_rand <- matrix(rand, dimnames=list(c("W"),c("W"))) #Var(ranef)
var_rand
df <- train_dat
#calculate theta-hats
X <- df %>%
mutate(trt = 1) %>%
dplyr::select(trt, age) %>%
as.matrix() #X (same as Z in this model)
X
Z <- X[,1]
Z
Z %*% var_rand %*% t(Z)
vcov_theta <- X %*% var_beta %*% t(X) + Z %*% var_rand %*% t(Z)
#matrix calculation
beta <- matrix(fixef(mod)[c("W","W:age")], nrow=2) #beta-hat
var_beta <- fc[c("W","W:age"),c("W","W:age")] #Var(beta-hat)
#calculate theta-hats
X <- df %>%
mutate(trt = 1) %>%
dplyr::select(trt, age) %>%
as.matrix() #X
mean_theta <- X %*% beta %>% c() #theta-hat
vcov_theta <- X %*% var_beta %*% t(X) + Z %*% var_rand %*% t(Z)
var_theta <- diag(vcov_theta) #Var(theta-hat)
var_theta
rep(0,2)
c(0,0)
nrow(var_rand)
sgn(1)
sign(1)
sign(-1)
sign(-2)
sign(0)
sign(-10000)
sign(1003980)
library(tidyverse)
library(rsample)
library(grf)
library(fastDummies)
library(nnet)
# set up data
N <- 100
K <- 10
n_mean <- 500
n_sd <- 0
eps_target <- 0
settings <- expand.grid(eps_combo = c("0.05 0.05 0.05", "0.05 1 0.05", "0.05 1 1",
"1 1 1", "1 3 1"),
distribution = c("same", "varying_madrs", "halfdiff_madrsage", "separate_age"),
target_dist = c("same", "upweight", "different"),
iteration = c(1:1000)) %>%
separate(eps_combo, into=c("eps_study_m", "eps_study_tau", "eps_study_age"), sep=" ") %>%
mutate(eps_study_m = as.numeric(eps_study_m),
eps_study_tau = as.numeric(eps_study_tau),
eps_study_age = as.numeric(eps_study_age))
i=1
eps_study_m <- settings$eps_study_m[i]
eps_study_tau <- settings$eps_study_tau[i]
eps_study_age <- settings$eps_study_age[i]
distribution <- settings$distribution[i]
target_dist <- settings$target_dist[i]
iteration <- settings$iteration[i]
seed <- i
iteration
source("R/MDD_Generation_OOSEst.R")
## Simulate training and target (OOS) data
sim_dat <- gen_mdd(K, n_mean, n_sd, eps_study_m, eps_study_tau,
eps_study_age, distribution, target_dist, eps_target)
train_dat <- sim_dat[["train_dat"]]
target_dat <- sim_dat[["target_dat"]]
View(train_dat)
summary(train_dat)
## Fit mixed effects models
#correct
mod <- lmer(Y ~  madrs + sex + W*age +
(W + W:age | S), data=train_dat,
control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=10000)))
sum <- summary(mod)
#incorrect
mod_wrong <- lmer(Y ~  madrs + sex + W*age +
(W | S), data=train_dat,
control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=10000)))
sum <- summary(mod_wrong)
sum
## Fit mixed effects models
#correct
mod <- lmer(Y ~  madrs + sex + W*age +
(W + W:age | S), data=train_dat,
control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=10000)))
sum <- summary(mod)
#incorrect
mod_wrong <- lmer(Y ~  madrs + sex + W*age +
(W | S), data=train_dat,
control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=10000)))
sum_wrong <- summary(mod_wrong)
sum
sum_wrong
## Calculate mean and CIs for individuals and assess accuracy
#confidence interval
glht_train <- glht_ci(train_dat, mod)
#prediction interval by hand ####
#get variance components of model
matrix_var <- function(mod, rand_int=T) {
#calculate variances
fc <- vcov(mod) #covariance matrix of fixed effects
rc <- as.data.frame(VarCorr(mod)) #variance and covariances of random effects
#matrix calculation
beta <- matrix(fixef(mod)[c("W","W:age")], nrow=2) #beta-hat
var_beta <- fc[c("W","W:age"),c("W","W:age")] #Var(beta-hat)
if (rand_int == T) {
rand <- rc[c(which(rc$var1=="W" & is.na(rc$var2)==T),
which(rc$var1=="W" & rc$var2=="W:age"),
which(rc$var1=="W" & rc$var2=="W:age"),
which(rc$var1=="W:age" & is.na(rc$var2)==T)), "vcov"] #can I clean this up??
var_rand <- matrix(rand, nrow=2, dimnames=list(c("W","W:age"),c("W","W:age"))) #Var(ranef)
} else {
rand <- rc[c(which(rc$var1=="W" & is.na(rc$var2)==T)), "vcov"] #can I clean this up??
var_rand <- matrix(rand, dimnames=list(c("W"),c("W"))) #Var(ranef)
}
return(list(beta=beta, var_beta=var_beta, var_rand=var_rand))
}
#add pis to dataset
manual_pi <- function(df, mod, K, rand_int=T) {
#get variances
res <- matrix_var(mod, rand_int)
beta <- res$beta
var_beta <- res$var_beta
var_rand <- res$var_rand
#calculate theta-hats
X <- df %>%
mutate(trt = 1) %>%
dplyr::select(trt, age) %>%
as.matrix() #X
if (rand_int == T) { Z <- X } else { Z <- X[,1] }
mean_theta <- X %*% beta %>% c() #theta-hat
vcov_theta <- X %*% var_beta %*% t(X) + Z %*% var_rand %*% t(Z)
var_theta <- diag(vcov_theta) #Var(theta-hat)
#prediction interval
pred_lower <- mean_theta + qt(.025, K-2)*sqrt(var_theta)
pred_upper <- mean_theta - qt(.025, K-2)*sqrt(var_theta)
df <- df %>%
mutate(lower = pred_lower,
mean = mean_theta,
upper = pred_upper)
return(df)
}
#confidence interval by glht ####
#get ci based on x=age (as a character)
age_ci <- function(x, mod) {
ci <- glht(mod, linfct=paste0("W +",x,"*W:age = 0"))
mean <- coef(ci) %>% as.numeric()
sd <- sqrt(vcov(ci)[1,1])
lower <- mean - 1.96*sd %>% as.numeric()
upper <- mean + 1.96*sd %>% as.numeric()
return(c(lower=lower, mean=mean, upper=upper))
}
#add cis to dataset
glht_ci <- function(df, mod) {
ages <- as.character(df$age)
cis <- map_dfr(.x=ages, .f=age_ci, mod=mod)
df <- df %>%
bind_cols(cis)
return(df)
}
#prediction interval by bootstrap ####
#create intervals from bootstrap
sample_cate <- function(x, boot_fix, boot_rand, rand_int=T) {
#get cate|x according to each coefficient
if (rand_int == T) {
cates <- (boot_fix$W + boot_rand$W) +
(boot_fix$W.age + boot_rand$W.age)*x
} else {
cates <- (boot_fix$W + boot_rand$W) +
(boot_fix$W.age)*x
}
#calculate interval over all iterations
mean <- mean(cates)
sd <- sd(cates)
lower <- mean - 1.96*sd
upper <- mean + 1.96*sd
return(c(lower=lower, mean=mean, upper=upper))
}
#bootstrap and add intervals to data
boot_pi <- function(df, mod, rand_int=T) {
#get var-covar of fixed and random effects from model
res <- matrix_var(mod, rand_int)
#randomly sample fixed and random coefficients
boot_fix <- mvrnorm(n=1000, mu=c(res$beta), Sigma=res$var_beta) %>%
data.frame()
boot_rand <- mvrnorm(n=1000, mu=rep(0, nrow(res$var_rand)), Sigma=res$var_rand) %>%
data.frame() #assume ranefs have mean 0
#apply coefficients to estimate cate for all ages
intervals <- map_dfr(.x=df$age, .f=sample_cate,
boot_fix=boot_fix, boot_rand=boot_rand, rand_int=rand_int)
df <- df %>%
bind_cols(intervals)
return(df)
}
#check results for all methods ####
assess_interval <- function(train_dat, target_dat) {
#calculate mse
train_mse <- mean((train_dat$mean - train_dat$tau)^2)
target_mse <- mean((target_dat$mean - target_dat$tau)^2)
#calculate coverage
train_coverage <- sum(train_dat$tau >= train_dat$lower & train_dat$tau <= train_dat$upper)/nrow(train_dat)
target_coverage <- sum(target_dat$tau >= target_dat$lower & target_dat$tau <= target_dat$upper)/nrow(target_dat)
#calculate length
train_length <- mean(train_dat$upper - train_dat$lower)
target_length <- mean(target_dat$upper - target_dat$lower)
#calculate signficance
train_significance <- sum(sign(train_dat$lower) == sign(train_dat$upper))/nrow(train_dat)
target_significance <- sum(sign(target_dat$lower) == sign(target_dat$upper))/nrow(target_dat)
return(c(train_mse = train_mse, target_mse = target_mse,
train_coverage = train_coverage, target_coverage = target_coverage,
train_length = train_length, target_length = target_length,
train_significance = train_significance, target_significance = target_significance))
}
## Calculate mean and CIs for individuals and assess accuracy
#confidence interval
glht_train <- glht_ci(train_dat, mod)
glht_target <- glht_ci(target_dat, mod)
glht_res <- assess_interval(glht_train, glht_target)
#confidence interval - incorrectly specified
glht_train_wrong <- glht_ci(train_dat, mod_wrong)
glht_target_wrong <- glht_ci(target_dat, mod_wrong)
glht_res_wrong <- assess_interval(glht_train_wrong, glht_target_wrong)
View(glht_train)
View(glht_train_wrong)
glht_res
glht_res_wrong
#manual PI
manual_train <- manual_pi(train_dat, mod, K, rand_int=T)
manual_target <- manual_pi(target_dat, mod, K, rand_int=T)
manual_res <- assess_interval(manual_train, manual_target)
#manual PI - incorrectly specified
manual_train_wrong <- manual_pi(train_dat, mod_wrong, K, rand_int=F)
manual_target_wrong <- manual_pi(target_dat, mod_wrong, K, rand_int=F)
manual_res_wrong <- assess_interval(manual_train_wrong, manual_target_wrong)
#bootstrap PI
boot_train <- boot_pi(train_dat, mod, rand_int=T)
boot_target <- boot_pi(target_dat, mod, rand_int=T)
boot_res <- assess_interval(boot_train, boot_target)
#bootstrap PI - incorrectly specified
boot_train_wrong <- boot_pi(train_dat, mod_wrong, rand_int=F)
boot_target_wrong <- boot_pi(target_dat, mod_wrong, rand_int=F)
boot_res_wrong <- assess_interval(boot_train_wrong, boot_target_wrong)
manual_res
manual_res_wrong
boot_res
boot_res_wrong
library(tidyverse)
library(rsample)
library(grf)
library(fastDummies)
library(nnet)
source("R/Bootstrap_OOSEst.R")
source("R/MDD_Generation_OOSEst.R")
source("R/MA_OOSEst.R")
source("R/MDD_Generation_OOSEst.R")
source("R/MA_OOSEst.R")
# set up data
N <- 100
K <- 10
n_mean <- 200
n_sd <- 0
eps_target <- 0
settings <- expand.grid(eps_combo = c("0.05 0.05 0.05", "0.05 1 0.05", "0.05 1 1",
"1 1 1", "1 3 1"),
distribution = c("same", "varying_madrs", "halfdiff_madrsage", "separate_age"),
target_dist = c("same", "upweight", "different"),
iteration = c(1:1000)) %>%
separate(eps_combo, into=c("eps_study_m", "eps_study_tau", "eps_study_age"), sep=" ") %>%
mutate(eps_study_m = as.numeric(eps_study_m),
eps_study_tau = as.numeric(eps_study_tau),
eps_study_age = as.numeric(eps_study_age))
i=1
eps_study_m <- settings$eps_study_m[i]
eps_study_tau <- settings$eps_study_tau[i]
eps_study_age <- settings$eps_study_age[i]
distribution <- settings$distribution[i]
target_dist <- settings$target_dist[i]
iteration <- settings$iteration[i]
seed <- i
#now code
set.seed(seed)
results <- compare_oos(N=N, K=K, n_mean=n_mean, n_sd=n_sd, eps_study_m=eps_study_m,
eps_study_tau=eps_study_tau, eps_study_age=eps_study_age,
distribution=distribution, target_dist=target_dist, eps_target=eps_target)
source("R/MA_OOSEst.R")
results <- compare_oos(N=N, K=K, n_mean=n_mean, n_sd=n_sd, eps_study_m=eps_study_m,
eps_study_tau=eps_study_tau, eps_study_age=eps_study_age,
distribution=distribution, target_dist=target_dist, eps_target=eps_target)
results
