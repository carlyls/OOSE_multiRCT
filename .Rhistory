}
Z <- do.call("bdiag", Zlist) %>% as.matrix()
var_rand <- do.call("bdiag", var_rand_train) %>% as.matrix()
mean_theta <- X %*% beta + Z %*% u %>% c()
} else { #target data doesn't require block diagonal matrices
if (rand_int == T) { Z <- X } else { Z <- X[,1] }
mean_theta <- X %*% beta %>% c() #theta-hat
}
mean_theta
View(cbind(p, mean_theta))
head(Z)
head(X)
head(train_dat)
sim_dat <- gen_mdd(K, n_mean, n_sd, n_target, eps_study_m, eps_study_tau,
eps_study_age, distribution, target_dist)
train_dat <- sim_dat[["train_dat"]]
target_dat <- sim_dat[["target_dat"]]
train_dat <- train_dat %>%
mutate(intercept = 1,
W_age = W*age)
target_dat <- target_dat %>%
mutate(intercept = 1,
W_age = W*age)
head(train_dat)
## Fit mixed effects models
#correct
mod <- lmer(Y ~  0 + intercept + madrs + sex + W + age + W_age +
(0 + intercept + W + W_age | S), data=train_dat,
control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=10000)))
sum <- summary(mod)
#prediction interval by hand ####
beta <- fixef(mod) #beta-hat
u <- ranef(mod)$S %>% t() %>% matrix()
fc <- vcov(mod) #covariance matrix of fixed effects
rc <- Matrix::bdiag(VarCorr(mod))
X <- train_dat %>%
mutate(W = 1,
W_age = age,
intercept = 0,
madrs = 0,
sex = 0,
age = 0)
head(X)
p <- predict(mod, X)
p
## Fit mixed effects models
#correct
mod <- lmer(Y ~  madrs + sex + W*age +
(W + W:age | S), data=train_dat,
control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=10000)))
sum <- summary(mod)
rand_int=T
#get variances
res <- matrix_var(mod, rand_int)
beta <- res$beta
var_beta <- res$var_beta
u <- res$u
var_rand <- res$var_rand
#calculate theta-hats
X <- df %>%
mutate(trt = 1) %>%
dplyr::select(trt, age) %>%
as.matrix() #X
if ("S" %in% names(df)) { #training data structure is different
Zlist <- list()
var_rand_train <- list()
for (s in 1:K) {
X_S <- X[df$S==s,]
if (rand_int == T) { Z_S <- X_S } else { Z_S <- X_S[,1] }
Zlist[[s]] <- Z_S
var_rand_train[[s]] <- var_rand
}
Z <- do.call("bdiag", Zlist) %>% as.matrix()
var_rand <- do.call("bdiag", var_rand_train) %>% as.matrix()
mean_theta <- X %*% beta + Z %*% u %>% c()
} else { #target data doesn't require block diagonal matrices
if (rand_int == T) { Z <- X } else { Z <- X[,1] }
mean_theta <- X %*% beta %>% c() #theta-hat
}
vcov_theta <- X %*% var_beta %*% t(X) + Z %*% var_rand %*% t(Z)
var_theta <- diag(vcov_theta) #Var(theta-hat)
View(cbind(mean_theta, p))
head(X)
## Fit mixed effects models
#correct
mod <- lmer(Y ~  0 + intercept + madrs + sex + W + age + W_age +
(0 + intercept + W + W_age | S), data=train_dat,
control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=10000)))
sum <- summary(mod)
#prediction interval by hand ####
beta <- fixef(mod) #beta-hat
u <- ranef(mod)$S %>% t() %>% matrix()
fc <- vcov(mod) #covariance matrix of fixed effects
rc <- Matrix::bdiag(VarCorr(mod))
beta
head(train_dat)
df <- train_dat
#get variances
res <- matrix_var(mod, rand_int)
beta <- res$beta
var_beta <- res$var_beta
u <- res$u
var_rand <- res$var_rand
#calculate theta-hats
X <- df %>%
mutate(trt = 1) %>%
dplyr::select(trt, age) %>%
as.matrix() #X
## Fit mixed effects models
#correct
mod <- lmer(Y ~  madrs + sex + W*age +
(W + W:age | S), data=train_dat,
control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=10000)))
sum <- summary(mod)
#get variances
res <- matrix_var(mod, rand_int)
beta <- res$beta
var_beta <- res$var_beta
u <- res$u
var_rand <- res$var_rand
#calculate theta-hats
X <- df %>%
mutate(trt = 1) %>%
dplyr::select(trt, age) %>%
as.matrix() #X
if ("S" %in% names(df)) { #training data structure is different
Zlist <- list()
var_rand_train <- list()
for (s in 1:K) {
X_S <- X[df$S==s,]
if (rand_int == T) { Z_S <- X_S } else { Z_S <- X_S[,1] }
Zlist[[s]] <- Z_S
var_rand_train[[s]] <- var_rand
}
Z <- do.call("bdiag", Zlist) %>% as.matrix()
var_rand <- do.call("bdiag", var_rand_train) %>% as.matrix()
mean_theta <- X %*% beta + Z %*% u %>% c()
} else { #target data doesn't require block diagonal matrices
if (rand_int == T) { Z <- X } else { Z <- X[,1] }
mean_theta <- X %*% beta %>% c() #theta-hat
}
View(cbind(p, mean_theta))
all.equal(p, mean_theta)
sum(p==mean_theta)
Z <- X %>% dplyr::select(-S)
X <- train_dat %>%
mutate(W = 1,
W_age = age,
intercept = 0,
madrs = 0,
sex = 0,
age = 0)
Z <- X %>% dplyr::select(-S)
predict(mod, Z)
Z <- X %>% mutate(S=NA)
predict(mod, Z)
predict(mod, Z, allow.new.levels=T)
sim_dat <- gen_mdd(K, n_mean, n_sd, n_target, eps_study_m, eps_study_tau,
eps_study_age, distribution, target_dist)
train_dat <- sim_dat[["train_dat"]]
target_dat <- sim_dat[["target_dat"]]
mod <- lmer(Y ~  madrs + sex + W*age +
(W + W:age | S), data=train_dat,
control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=10000)))
sum <- summary(mod)
sum
?lmer
formula(mod)
covars_fix <- c("age")
covars_rand <- c("age")
?collapse
covars_fix <- c("age","madrs")
paste(covars_fix, collapse = "+")
?paste
paste("W*", covars_fix)
paste("W", covars_fix, sep=" * ", collapse = " + ")
formula <- as.formula(paste0("Y ~ madrs + sex + ",
paste("W", covars_fix, sep="*", collapse=" + ")))
formula
formula(mod)
formula <- as.formula(paste0("Y ~ madrs + sex + ",
paste("W", covars_fix, sep="*", collapse=" + "),
" + (W + ",
paste("W", covars_rand, sep=":", collapse=" + "),
" | S)"))
formula
covars_fix <- c("age")
covars_rand <- c("age")
formula <- as.formula(paste0("Y ~ madrs + sex + ",
paste("W", covars_fix, sep="*", collapse=" + "),
" + (W + ",
paste("W", covars_rand, sep=":", collapse=" + "),
" | S)"))
formula
mod <- lmer(formula, data=train_dat,
control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=10000)))
sum <- summary(mod)
sum
#calculate variances
fc <- vcov(mod) #covariance matrix of fixed effects
rc <- as.data.frame(VarCorr(mod)) #variance and covariances of random effects
fc
rc
Matrix::bdiag(VarCorr(mod))
fc
fixef(mod)
names(fixef(mod))
fixef(mod)[which(grepl("W", names(fixef(mod)))==T)]
#fixed effects
beta <- matrix(fixef(mod)[c("W","W:age")], nrow=2) #beta-hat
beta
fc
?grep
grep("W", names(fixef(mod)))
#fixed effects
beta <- fixef(mod)[grep("W", names(fixef(mod)))] #beta-hat
beta
grep("W", rownames(fc))
var_beta <- fc[grep("W", rownames(fc)),
grep("W", colnames(fc))] #Var(beta-hat)
var_beta
ranef(mod)$S
#random effects
u <- ranef(mod)$S[grep("W", colnames(ranef(mod)$S))] %>% t() %>% matrix()
u
ranef(mod)$S[grep("W", colnames(ranef(mod)$S))]
ranef(mod)$S[grep("W", colnames(ranef(mod)$S))] %>% t()
rand <- rc[c(which(rc$var1=="W" & is.na(rc$var2)==T),
which(rc$var1=="W" & rc$var2=="W:age"),
which(rc$var1=="W" & rc$var2=="W:age"),
which(rc$var1=="W:age" & is.na(rc$var2)==T)), "vcov"]
var_rand <- matrix(rand, nrow=2, dimnames=list(c("W","W:age"),c("W","W:age"))) #Var(ranef)
var_rand
rc
rc <- Matrix::bdiag(VarCorr(mod)) #variance and covariances of random effects
rc
var_rand <- rc[grep("W", rownames(rc)),
grep("W", colnames(rc))]
var_rand
#get variance components of model
matrix_var <- function(mod) {
#calculate variances
fc <- vcov(mod) #covariance matrix of fixed effects
rc <- Matrix::bdiag(VarCorr(mod)) #variance and covariances of random effects
#fixed effects
beta <- fixef(mod)[grep("W", names(fixef(mod)))] #beta-hat
var_beta <- fc[grep("W", rownames(fc)),
grep("W", colnames(fc))] #Var(beta-hat)
#random effects
u <- ranef(mod)$S[grep("W", colnames(ranef(mod)$S))] %>% t() %>% matrix()
var_rand <- rc[grep("W", rownames(rc)),
grep("W", colnames(rc))]
return(list(beta=beta, var_beta=var_beta, u=u, var_rand=var_rand))
}
matrix_var(mod)
#prediction interval by hand ####
#get variance components of model
matrix_var <- function(mod, rand_int=T) {
#calculate variances
fc <- vcov(mod) #covariance matrix of fixed effects
rc <- as.data.frame(VarCorr(mod)) #variance and covariances of random effects
#fixed effects
beta <- matrix(fixef(mod)[c("W","W:age")], nrow=2) #beta-hat
var_beta <- fc[c("W","W:age"),c("W","W:age")] #Var(beta-hat)
#random effects
if (rand_int == T) {
u <- ranef(mod)$S[c("W","W:age")] %>% t() %>% matrix() #u-hat
rand <- rc[c(which(rc$var1=="W" & is.na(rc$var2)==T),
which(rc$var1=="W" & rc$var2=="W:age"),
which(rc$var1=="W" & rc$var2=="W:age"),
which(rc$var1=="W:age" & is.na(rc$var2)==T)), "vcov"]
var_rand <- matrix(rand, nrow=2, dimnames=list(c("W","W:age"),c("W","W:age"))) #Var(ranef)
} else {
u <- ranef(mod)$S[c("W")] %>% t() %>% matrix() #u-hat
rand <- rc[c(which(rc$var1=="W" & is.na(rc$var2)==T)), "vcov"]
var_rand <- matrix(rand, dimnames=list(c("W"),c("W"))) #Var(ranef)
}
return(list(beta=beta, var_beta=var_beta, u=u, var_rand=var_rand))
}
matrix_var(mod)
#fixed effects
beta <- fixef(mod)[grep("W", names(fixef(mod)))] %>% matrix() #beta-hat
beta
df <- train-dat
df <- train_dat
covars_fix
#calculate theta-hats
X <- df %>%
dplyr::select(W, all_of(covars_fix)) %>%
mutate(W = 1) %>%
as.matrix()
head(X)
Z <- df %>%
dplyr::select(W, all_of(covars_rand)) %>%
mutate(W = 1) %>%
as.matrix()
head(Z)
var_rand_train <- list(var_rand, rep=K)
var_rand_train
?list
rep(list(var_rand),K)
var_rand <- var_rand %>%
list() %>%
rep(K)
var_rand
var_rand <- var_rand[[1]]
var_rand
source("R/MDD_Generation_OOSEst.R")
#prediction interval by hand ####
#get variance components of model
matrix_var <- function(mod, rand_int=T) {
#calculate variances
fc <- vcov(mod) #covariance matrix of fixed effects
rc <- as.data.frame(VarCorr(mod)) #variance and covariances of random effects
#fixed effects
beta <- matrix(fixef(mod)[c("W","W:age")], nrow=2) #beta-hat
var_beta <- fc[c("W","W:age"),c("W","W:age")] #Var(beta-hat)
#random effects
if (rand_int == T) {
u <- ranef(mod)$S[c("W","W:age")] %>% t() %>% matrix() #u-hat
rand <- rc[c(which(rc$var1=="W" & is.na(rc$var2)==T),
which(rc$var1=="W" & rc$var2=="W:age"),
which(rc$var1=="W" & rc$var2=="W:age"),
which(rc$var1=="W:age" & is.na(rc$var2)==T)), "vcov"]
var_rand <- matrix(rand, nrow=2, dimnames=list(c("W","W:age"),c("W","W:age"))) #Var(ranef)
} else {
u <- ranef(mod)$S[c("W")] %>% t() %>% matrix() #u-hat
rand <- rc[c(which(rc$var1=="W" & is.na(rc$var2)==T)), "vcov"]
var_rand <- matrix(rand, dimnames=list(c("W"),c("W"))) #Var(ranef)
}
return(list(beta=beta, var_beta=var_beta, u=u, var_rand=var_rand))
}
#add pis to dataset
manual_pi <- function(df, mod, K, rand_int=T) {
#get variances
res <- matrix_var(mod, rand_int)
beta <- res$beta
var_beta <- res$var_beta
u <- res$u
var_rand <- res$var_rand
#calculate theta-hats
X <- df %>%
mutate(trt = 1) %>%
dplyr::select(trt, age) %>%
as.matrix() #X
if ("S" %in% names(df)) { #training data structure is different
Zlist <- list()
var_rand_train <- list()
for (s in 1:K) {
X_S <- X[df$S==s,]
if (rand_int == T) { Z_S <- X_S } else { Z_S <- X_S[,1] }
Zlist[[s]] <- Z_S
var_rand_train[[s]] <- var_rand
}
Z <- do.call("bdiag", Zlist) %>% as.matrix()
var_rand <- do.call("bdiag", var_rand_train) %>% as.matrix()
mean_theta <- X %*% beta + Z %*% u %>% c()
} else { #target data doesn't require block diagonal matrices
if (rand_int == T) { Z <- X } else { Z <- X[,1] }
mean_theta <- X %*% beta %>% c() #theta-hat
}
vcov_theta <- X %*% var_beta %*% t(X) + Z %*% var_rand %*% t(Z)
var_theta <- diag(vcov_theta) #Var(theta-hat)
#prediction interval
pred_lower <- mean_theta + qt(.025, K-2)*sqrt(var_theta)
pred_upper <- mean_theta - qt(.025, K-2)*sqrt(var_theta)
df <- df %>%
mutate(lower = pred_lower,
mean = mean_theta,
upper = pred_upper)
return(df)
}
## Simulate training and target (OOS) data
sim_dat <- gen_mdd(K, n_mean, n_sd, n_target, eps_study_m, eps_study_tau,
eps_study_age, distribution, target_dist)
train_dat <- sim_dat[["train_dat"]]
target_dat <- sim_dat[["target_dat"]]
## Fit mixed effects models
#correct
mod <- lmer(Y ~  madrs + sex + W*age +
(W + W:age | S), data=train_dat,
control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=10000)))
sum <- summary(mod)
#incorrect
mod_wrong <- lmer(Y ~  madrs + sex + W*age +
(W | S), data=train_dat,
control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=10000)))
sum_wrong <- summary(mod_wrong)
#manual PI
manual_train <- manual_pi(train_dat, mod, K, rand_int=T)
manual_target <- manual_pi(target_dat, mod, K, rand_int=T)
manual_res <- assess_interval(manual_train, manual_target)
#check results for all methods ####
assess_interval <- function(train_dat, target_dat) {
#calculate mse
train_mse <- mean((train_dat$mean - train_dat$tau)^2)
target_mse <- mean((target_dat$mean - target_dat$tau)^2)
#calculate coverage
train_coverage <- sum(train_dat$tau >= train_dat$lower & train_dat$tau <= train_dat$upper)/nrow(train_dat)
target_coverage <- sum(target_dat$tau >= target_dat$lower & target_dat$tau <= target_dat$upper)/nrow(target_dat)
#calculate length
train_length <- mean(train_dat$upper - train_dat$lower)
target_length <- mean(target_dat$upper - target_dat$lower)
#calculate signficance
train_significance <- sum(sign(train_dat$lower) == sign(train_dat$upper))/nrow(train_dat)
target_significance <- sum(sign(target_dat$lower) == sign(target_dat$upper))/nrow(target_dat)
return(c(train_mse = train_mse, target_mse = target_mse,
train_coverage = train_coverage, target_coverage = target_coverage,
train_length = train_length, target_length = target_length,
train_significance = train_significance, target_significance = target_significance))
}
manual_res <- assess_interval(manual_train, manual_target)
manual_ress
manual_res
a <- manual_res
#get variance components of model
matrix_var <- function(mod) {
#calculate variances
fc <- vcov(mod) #covariance matrix of fixed effects
rc <- Matrix::bdiag(VarCorr(mod)) #variance and covariances of random effects
#fixed effects
beta <- fixef(mod)[grep("W", names(fixef(mod)))] %>% matrix() #beta-hat
var_beta <- fc[grep("W", rownames(fc)),
grep("W", colnames(fc))] #Var(beta-hat)
#random effects
u <- ranef(mod)$S[grep("W", colnames(ranef(mod)$S))] %>% t() %>% matrix()
var_rand <- rc[grep("W", rownames(rc)),
grep("W", colnames(rc))]
return(list(beta=beta, var_beta=var_beta, u=u, var_rand=var_rand))
}
#add pis to dataset
manual_pi <- function(df, mod, K, covars_fix, covars_rand) {
#get variances
res <- matrix_var(mod)
beta <- res$beta
var_beta <- res$var_beta
u <- res$u
var_rand <- res$var_rand
#calculate theta-hats
X <- df %>%
dplyr::select(W, all_of(covars_fix)) %>%
mutate(W = 1) %>%
as.matrix()
Z <- df %>%
dplyr::select(W, all_of(covars_rand)) %>%
mutate(W = 1) %>%
as.matrix()
if ("S" %in% names(df)) { #training data structure is different
Zlist <- list()
var_rand_train <- rep(list(var_rand), K)
var_rand <- do.call("bdiag", var_rand_train) %>% as.matrix()
for (s in 1:K) {
Z_S <- Z[df$S==s,]
Zlist[[s]] <- Z_S
}
Z <- do.call("bdiag", Zlist) %>% as.matrix()
mean_theta <- X %*% beta + Z %*% u %>% c()
} else { #don't know u's for target data
mean_theta <- X %*% beta %>% c() #theta-hat
}
vcov_theta <- X %*% var_beta %*% t(X) + Z %*% var_rand %*% t(Z)
var_theta <- diag(vcov_theta) #Var(theta-hat)
#prediction interval
pred_lower <- mean_theta + qt(.025, K-2)*sqrt(var_theta)
pred_upper <- mean_theta - qt(.025, K-2)*sqrt(var_theta)
df <- df %>%
mutate(lower = pred_lower,
mean = mean_theta,
upper = pred_upper)
return(df)
}
manual_train <- manual_pi(train_dat, mod, K, covars_fix, covars_rand)
manual_target <- manual_pi(target_dat, mod, K, covars_fix, covars_rand)
manual_res <- assess_interval(manual_train, manual_target)
manual_res
a
df <- target_dat
#get variances
res <- matrix_var(mod)
beta <- res$beta
var_beta <- res$var_beta
u <- res$u
var_rand <- res$var_rand
#calculate theta-hats
X <- df %>%
dplyr::select(W, all_of(covars_fix)) %>%
mutate(W = 1) %>%
as.matrix()
Z <- df %>%
dplyr::select(W, all_of(covars_rand)) %>%
mutate(W = 1) %>%
as.matrix()
head(X)
head(Z)
if ("S" %in% names(df)) { #training data structure is different
Zlist <- list()
var_rand_train <- rep(list(var_rand), K)
var_rand <- do.call("bdiag", var_rand_train) %>% as.matrix()
for (s in 1:K) {
Z_S <- Z[df$S==s,]
Zlist[[s]] <- Z_S
}
Z <- do.call("bdiag", Zlist) %>% as.matrix()
mean_theta <- X %*% beta + Z %*% u %>% c()
} else { #don't know u's for target data
mean_theta <- X %*% beta %>% c() #theta-hat
}
head(Z)
head(mean_theta)
beta
2.4892840-0.87771748*0.8238597
var_rand
