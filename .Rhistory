Z[[s]] <- Z_S
}
rand_int=T
X <- Z <- list()
for (s in 1:K) {
X_S <- df %>%
filter(S == s) %>%
mutate(trt = 1) %>%
dplyr::select(trt, age) %>%
as.matrix()
if (rand_int == T) { Z_S <- X_S } else { Z_S <- X_S[,1] }
X[[s]] <- X_S
Z[[s]] <- Z_S
}
X
X <- lapply(X, rbind)
X
X <- Z <- list()
for (s in 1:K) {
X_S <- df %>%
filter(S == s) %>%
mutate(trt = 1) %>%
dplyr::select(trt, age) %>%
as.matrix()
if (rand_int == T) { Z_S <- X_S } else { Z_S <- X_S[,1] }
X[[s]] <- X_S
Z[[s]] <- Z_S
}
Xmat <- do.call("rbind", X)
Xmat
nrow(Xmat)
bdiag(matrix(1:4, 2), diag(3))
?bdiag
bdiag(matrix(1:4, 2), diag(3)) %>% as.matrix()
bdiag(Z[[1]], Z[[2]])
bdiag(Z[[1]]:Z[[10]])
do.call("bdiag", Z)
?separate
?split
#calculate theta-hats
X <- df %>%
mutate(trt = 1) %>%
dplyr::select(trt, age) %>%
as.matrix() #X
X
X[S==s,]
X["S"==s,]
X[df$S==s,]
#calculate theta-hats
X <- df %>%
mutate(trt = 1) %>%
dplyr::select(trt, age) %>%
as.matrix() #X
df
if ("S" %in% names(df)) { #training data structure is different
Zlist <- list()
for (s in 1:K) {
X_S <- X[df$S==s,]
if (rand_int == T) { Z_S <- X_S } else { Z_S <- X_S[,1] }
Zlist[[s]] <- Z_S
}
Z <- do.call("bdiag", Zlist)
} else { #target data doesn't require stacking or block diagonal matrices
if (rand_int == T) { Z <- X } else { Z <- X[,1] }
}
View(Z)
View(as.matrix(Z))
Z
as.matrix(Z)
#calculate theta-hats
X <- df %>%
mutate(trt = 1) %>%
dplyr::select(trt, age) %>%
as.matrix() #X
if ("S" %in% names(df)) { #training data structure is different
Zlist <- list()
for (s in 1:K) {
X_S <- X[df$S==s,]
if (rand_int == T) { Z_S <- X_S } else { Z_S <- X_S[,1] }
Zlist[[s]] <- Z_S
}
Z <- do.call("bdiag", Zlist) %>% as.matrix()
} else { #target data doesn't require stacking or block diagonal matrices
if (rand_int == T) { Z <- X } else { Z <- X[,1] }
}
Z
u
Zlist <- ulist <- list()
Zlist <- ulist <- list()
for (s in 1:K) {
X_S <- X[df$S==s,]
if (rand_int == T) { Z_S <- X_S } else { Z_S <- X_S[,1] }
Zlist[[s]] <- Z_S
ulist[[s]] <- u[s,]
}
ulist
t
Zlist <- ulist <- list()
for (s in 1:K) {
X_S <- X[df$S==s,]
if (rand_int == T) { Z_S <- X_S } else { Z_S <- X_S[,1] }
Zlist[[s]] <- Z_S
ulist[[s]] <- u[s,] %>% t()
}
ulist
u
u <- t)u
u <- t(u)
u
Zlist <- ulist <- list()
for (s in 1:K) {
X_S <- X[df$S==s,]
if (rand_int == T) { Z_S <- X_S } else { Z_S <- X_S[,1] }
Zlist[[s]] <- Z_S
ulist[[s]] <- u[,s]
}
ulist
pivot_longer(u)
pivot_longer(data.frame(u))
data.frame(u)
do.call("rbind", ulist)
ranef(mod)$S[c("W","W:age")]
ranef(mod)$S[c("W","W:age")] %>% c()
matrix(u)
u
matrix(ranef(mod)$S[c("W","W:age")])
matrix(ranef(mod)$S[c("W","W:age")], ncol=1)
matrix(ranef(mod)$S[c("W","W:age")], ncol=10)
ranef(mod)$S[c("W","W:age")]
ranef(mod)$S[c("W","W:age")] %>% t()
ranef(mod)$S[c("W","W:age")] %>% t() %>% matrix()
#random effects
u <- ranef(mod)$S[c("W","W:age")] %>% t() %>% matrix() #u-hat
u
ranef(mod)
#prediction interval by hand ####
#get variance components of model
matrix_var <- function(mod, rand_int=T) {
#calculate variances
fc <- vcov(mod) #covariance matrix of fixed effects
rc <- as.data.frame(VarCorr(mod)) #variance and covariances of random effects
#fixed effects
beta <- matrix(fixef(mod)[c("W","W:age")], nrow=2) #beta-hat
var_beta <- fc[c("W","W:age"),c("W","W:age")] #Var(beta-hat)
#random effects
u <- ranef(mod)$S[c("W","W:age")] %>% t() %>% matrix() #u-hat
if (rand_int == T) {
rand <- rc[c(which(rc$var1=="W" & is.na(rc$var2)==T),
which(rc$var1=="W" & rc$var2=="W:age"),
which(rc$var1=="W" & rc$var2=="W:age"),
which(rc$var1=="W:age" & is.na(rc$var2)==T)), "vcov"]
var_rand <- matrix(rand, nrow=2, dimnames=list(c("W","W:age"),c("W","W:age"))) #Var(ranef)
} else {
rand <- rc[c(which(rc$var1=="W" & is.na(rc$var2)==T)), "vcov"]
var_rand <- matrix(rand, dimnames=list(c("W"),c("W"))) #Var(ranef)
}
return(list(beta=beta, var_beta=var_beta, u=u, var_rand=var_rand))
}
#get variances
res <- matrix_var(mod, rand_int)
beta <- res$beta
var_beta <- res$var_beta
u <- res$u
var_rand <- res$var_rand
beta
var_beta
u
var_rand
#calculate theta-hats
X <- df %>%
mutate(trt = 1) %>%
dplyr::select(trt, age) %>%
as.matrix() #X
head(X)
head(df)
if ("S" %in% names(df)) { #training data structure is different
Zlist <- list()
for (s in 1:K) {
X_S <- X[df$S==s,]
if (rand_int == T) { Z_S <- X_S } else { Z_S <- X_S[,1] }
Zlist[[s]] <- Z_S
}
Z <- do.call("bdiag", Zlist) %>% as.matrix()
} else { #target data doesn't require stacking or block diagonal matrices
if (rand_int == T) { Z <- X } else { Z <- X[,1] }
}
head(Z)
mean_theta <- X %*% beta + Z %*% u
mean_theta
mean_theta <- X %*% beta + Z %*% u %>% c()
mean_theta
mean_theta2 <- X %*% beta %>% c() #theta-hat
mean_theta2
View(cbind(mean_theta, mean_theta2))
View(cbind(mean_theta, mean_theta2, train_dat$tau))
mean((mean_theta-train_dat$tau)^2)
mean((mean_theta2-train_dat$tau)^2)
var_rand
Z %*% var_rand
VarCorr(mod)
VarCorr(mod) %>% data.frame()
VarCorr(mod) %>% as.data.frame()
var_rand <- do.call("bdiag", var_rand) %>% as.matrix()
do.call("bdiag", var_rand)
Zlist <- list()
var_rand_train <- list()
for (s in 1:K) {
X_S <- X[df$S==s,]
if (rand_int == T) { Z_S <- X_S } else { Z_S <- X_S[,1] }
Zlist[[s]] <- Z_S
var_rand_train[[s]] <- var_rand
}
var_rand_train
Z <- do.call("bdiag", Zlist) %>% as.matrix()
var_rand <- do.call("bdiag", var_rand) %>% as.matrix()
var_rand <- do.call("bdiag", var_rand_train) %>% as.matrix()
var_rand
vcov_theta <- X %*% var_beta %*% t(X) + Z %*% var_rand %*% t(Z)
Z %*% var_rand
vcov_theta <- X %*% var_beta %*% t(X) + Z %*% var_rand %*% t(Z)
vcov_theta
var_theta <- diag(vcov_theta) #Var(theta-hat)
var_theta
library(tidyverse)
library(rsample)
library(grf)
library(fastDummies)
library(nnet)
source("R/MDD_Generation_OOSEst.R")
source("R/MA_OOSEst.R")
# set up parameters
K <- 10
n_mean <- 200
n_sd <- 0
n_target <- 100
settings <- expand.grid(eps_study_m = c(0.05, 1),
eps_combo = c("0.05 0.05", "0.5 0.05", "0.5 0.5",
"1 0.05", "1 0.5", "1 1"),
distribution = c("same", "varying_madrs", "halfdiff_madrsage", "separate_age"),
target_dist = c("same", "different"),
iteration = c(1:100)) %>%
separate(eps_combo, into=c("eps_study_tau", "eps_study_age"), sep=" ") %>%
mutate(eps_study_tau = as.numeric(eps_study_tau),
eps_study_age = as.numeric(eps_study_age))
i=1
eps_study_m <- settings$eps_study_m[i]
eps_study_tau <- settings$eps_study_tau[i]
eps_study_age <- settings$eps_study_age[i]
distribution <- settings$distribution[i]
target_dist <- settings$target_dist[i]
iteration <- settings$iteration[i]
seed <- i
#now code
set.seed(seed)
results <- compare_oos(K=K, n_mean=n_mean, n_sd=n_sd, n_target=n_target, eps_study_m=eps_study_m,
eps_study_tau=eps_study_tau, eps_study_age=eps_study_age,
distribution=distribution, target_dist=target_dist)
## Simulate training and target (OOS) data
sim_dat <- gen_mdd(K, n_mean, n_sd, n_target, eps_study_m, eps_study_tau,
eps_study_age, distribution, target_dist)
train_dat <- sim_dat[["train_dat"]]
target_dat <- sim_dat[["target_dat"]]
## Fit mixed effects models
#correct
mod <- lmer(Y ~  madrs + sex + W*age +
(W + W:age | S), data=train_dat,
control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=10000)))
sum <- summary(mod)
#incorrect
mod_wrong <- lmer(Y ~  madrs + sex + W*age +
(W | S), data=train_dat,
control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=10000)))
sum_wrong <- summary(mod_wrong)
## Calculate mean and CIs for individuals and assess accuracy
#confidence interval
glht_train <- glht_ci(train_dat, mod)
glht_target <- glht_ci(target_dat, mod)
glht_res <- assess_interval(glht_train, glht_target)
#bootstrap PI
boot_train <- boot_pi(train_dat, mod, rand_int=T)
boot_target <- boot_pi(target_dat, mod, rand_int=T)
boot_res <- assess_interval(boot_train, boot_target)
boot_res
glht_res
#manual PI
manual_train <- manual_pi(train_dat, mod, K, rand_int=T)
manual_target <- manual_pi(target_dat, mod, K, rand_int=T)
manual_res <- assess_interval(manual_train, manual_target)
manual_res
#manual PI - incorrectly specified
manual_train_wrong <- manual_pi(train_dat, mod_wrong, K, rand_int=F)
df <- target_dat
rand_int=T
#get variances
res <- matrix_var(mod, rand_int)
beta <- res$beta
var_beta <- res$var_beta
u <- res$u
var_rand <- res$var_rand
#calculate theta-hats
X <- df %>%
mutate(trt = 1) %>%
dplyr::select(trt, age) %>%
as.matrix() #X
if ("S" %in% names(df)) { #training data structure is different
Zlist <- list()
var_rand_train <- list()
for (s in 1:K) {
X_S <- X[df$S==s,]
if (rand_int == T) { Z_S <- X_S } else { Z_S <- X_S[,1] }
Zlist[[s]] <- Z_S
var_rand_train[[s]] <- var_rand
}
Z <- do.call("bdiag", Zlist) %>% as.matrix()
var_rand <- do.call("bdiag", var_rand_train) %>% as.matrix()
mean_theta <- X %*% beta + Z %*% u %>% c()
} else { #target data doesn't require stacking or block diagonal matrices
if (rand_int == T) { Z <- X } else { Z <- X[,1] }
mean_theta <- X %*% beta %>% c() #theta-hat
}
vcov_theta <- X %*% var_beta %*% t(X) + Z %*% var_rand %*% t(Z)
var_theta <- diag(vcov_theta) #Var(theta-hat)
Z
X
var_rand
mean_theta
vcov_theta
var_theta
mod <- mod_wrong
rand_int=F
df <- train_dat
#get variances
res <- matrix_var(mod, rand_int)
ranef(mod)$S[c("W")]
u <- ranef(mod)$S[c("W")] %>% t() %>% matrix() #u-hat
u
rand <- rc[c(which(rc$var1=="W" & is.na(rc$var2)==T)), "vcov"]
var_rand <- matrix(rand, dimnames=list(c("W"),c("W"))) #Var(ranef)
#prediction interval by hand ####
#get variance components of model
matrix_var <- function(mod, rand_int=T) {
#calculate variances
fc <- vcov(mod) #covariance matrix of fixed effects
rc <- as.data.frame(VarCorr(mod)) #variance and covariances of random effects
#fixed effects
beta <- matrix(fixef(mod)[c("W","W:age")], nrow=2) #beta-hat
var_beta <- fc[c("W","W:age"),c("W","W:age")] #Var(beta-hat)
#random effects
if (rand_int == T) {
u <- ranef(mod)$S[c("W","W:age")] %>% t() %>% matrix() #u-hat
rand <- rc[c(which(rc$var1=="W" & is.na(rc$var2)==T),
which(rc$var1=="W" & rc$var2=="W:age"),
which(rc$var1=="W" & rc$var2=="W:age"),
which(rc$var1=="W:age" & is.na(rc$var2)==T)), "vcov"]
var_rand <- matrix(rand, nrow=2, dimnames=list(c("W","W:age"),c("W","W:age"))) #Var(ranef)
} else {
u <- ranef(mod)$S[c("W")] %>% t() %>% matrix() #u-hat
rand <- rc[c(which(rc$var1=="W" & is.na(rc$var2)==T)), "vcov"]
var_rand <- matrix(rand, dimnames=list(c("W"),c("W"))) #Var(ranef)
}
return(list(beta=beta, var_beta=var_beta, u=u, var_rand=var_rand))
}
mod
#get variances
res <- matrix_var(mod, rand_int)
beta <- res$beta
rand_int
var_beta <- res$var_beta
u <- res$u
var_rand <- res$var_rand
#calculate theta-hats
X <- df %>%
mutate(trt = 1) %>%
dplyr::select(trt, age) %>%
as.matrix() #X
if ("S" %in% names(df)) { #training data structure is different
Zlist <- list()
var_rand_train <- list()
for (s in 1:K) {
X_S <- X[df$S==s,]
if (rand_int == T) { Z_S <- X_S } else { Z_S <- X_S[,1] }
Zlist[[s]] <- Z_S
var_rand_train[[s]] <- var_rand
}
Z <- do.call("bdiag", Zlist) %>% as.matrix()
var_rand <- do.call("bdiag", var_rand_train) %>% as.matrix()
mean_theta <- X %*% beta + Z %*% u %>% c()
} else { #target data doesn't require stacking or block diagonal matrices
if (rand_int == T) { Z <- X } else { Z <- X[,1] }
mean_theta <- X %*% beta %>% c() #theta-hat
}
Z
X
var_rand
vcov_theta <- X %*% var_beta %*% t(X) + Z %*% var_rand %*% t(Z)
var_theta <- diag(vcov_theta) #Var(theta-hat)
vcov_theta
source("R/MDD_Generation_OOSEst.R")
source("R/MA_OOSEst.R")
# set up parameters
K <- 10
n_mean <- 200
n_sd <- 0
n_target <- 100
settings <- expand.grid(eps_study_m = c(0.05, 1),
eps_combo = c("0.05 0.05", "0.5 0.05", "0.5 0.5",
"1 0.05", "1 0.5", "1 1"),
distribution = c("same", "varying_madrs", "halfdiff_madrsage", "separate_age"),
target_dist = c("same", "different"),
iteration = c(1:100)) %>%
separate(eps_combo, into=c("eps_study_tau", "eps_study_age"), sep=" ") %>%
mutate(eps_study_tau = as.numeric(eps_study_tau),
eps_study_age = as.numeric(eps_study_age))
eps_study_m <- settings$eps_study_m[i]
eps_study_tau <- settings$eps_study_tau[i]
eps_study_age <- settings$eps_study_age[i]
distribution <- settings$distribution[i]
target_dist <- settings$target_dist[i]
iteration <- settings$iteration[i]
seed <- i
#now code
set.seed(seed)
results <- compare_oos(K=K, n_mean=n_mean, n_sd=n_sd, n_target=n_target, eps_study_m=eps_study_m,
eps_study_tau=eps_study_tau, eps_study_age=eps_study_age,
distribution=distribution, target_dist=target_dist)
results
View(results$all_res)
nrow(settings)
?nnet
library(tidyverse)
library(lme4)
library(rsample)
library(multcomp)
library(MASS)
#interior function
sample_dist <- function(K, k, n, Sigma, eps_study_m, eps_study_tau, eps_study_age, distribution) {
#define mu based on distribution input
if (distribution == "same") {
mu <- c(age=44.8971, sex=0.6784, smstat=0.3043, weight=79.0253, madrs=31.4088)
} else if (distribution == "varying_madrs") {
mu <- c(age=44.8971, sex=0.6784, smstat=0.3043, weight=79.0253, madrs=31.4088-k*1.5)
} else if (distribution == "halfdiff_madrsage") {
if (k%%2 == 0 ) {
mu <- c(age=50, sex=0.6784, smstat=0.3043, weight=79.0253, madrs=40)
} else {
mu <- c(age=44.8971, sex=0.6784, smstat=0.3043, weight=79.0253, madrs=31.4088)
}
} else if (distribution == "separate_age") {
ages <- seq(30, 55, length.out=K)
mu <- c(age=ages[k], sex=0.6784, smstat=0.3043, weight=79.0253, madrs=31.4088)
}
#simulate data
dat <- MASS::mvrnorm(n=n, mu=mu, Sigma=Sigma) %>%
as.data.frame() %>%
mutate(sex = ifelse(sex > 1-0.6784, 1, 0),
smstat = ifelse(smstat > 1-0.3043, 1, 0),
eps = rnorm(n=n, mean=0, sd=.05),
W = rbinom(n=n, size=1, prob=.5),
eps_m = rnorm(n=1, mean=0, sd=eps_study_m),
eps_tau = rnorm(n=1, mean=0, sd=eps_study_tau),
eps_age = rnorm(n=1, mean=0, sd=eps_study_age),
S = k)
return(dat)
}
source("R/MDD_Generation_OOSEst.R")
source("R/MA_OOSEst.R")
# set up parameters
K <- 10
n_mean <- 200
n_sd <- 0
n_target <- 100
settings <- expand.grid(eps_study_m = c(0.05, 1),
eps_combo = c("0.05 0", "0.5 0.05", "0.5 0.5",
"1 0.05", "1 0.5", "1 1"),
distribution = c("same", "varying_madrs", "halfdiff_madrsage", "separate_age"),
target_dist = c("same", "different"),
iteration = c(1:100)) %>%
separate(eps_combo, into=c("eps_study_tau", "eps_study_age"), sep=" ") %>%
mutate(eps_study_tau = as.numeric(eps_study_tau),
eps_study_age = as.numeric(eps_study_age))
i=1
eps_study_m <- settings$eps_study_m[i]
eps_study_tau <- settings$eps_study_tau[i]
eps_study_age <- settings$eps_study_age[i]
distribution <- settings$distribution[i]
target_dist <- settings$target_dist[i]
iteration <- settings$iteration[i]
seed <- i
#now code
set.seed(seed)
results <- compare_oos(K=K, n_mean=n_mean, n_sd=n_sd, n_target=n_target, eps_study_m=eps_study_m,
eps_study_tau=eps_study_tau, eps_study_age=eps_study_age,
distribution=distribution, target_dist=target_dist)
results
x <- knitr::kable(head(mtcars), "html")
# Add a row of header with 3 columns on the top of the table. The column
# span for the 2nd and 3rd one are 5 & 6.
add_header_above(x, c(" ", "Group 1" = 5, "Group 2" = 6))
library(kableExtra)
x <- knitr::kable(head(mtcars), "html")
# Add a row of header with 3 columns on the top of the table. The column
# span for the 2nd and 3rd one are 5 & 6.
add_header_above(x, c(" ", "Group 1" = 5, "Group 2" = 6))
library(kableExtra)
rownames = c("Positive", "Negative")
colnames = c("Positive", "Negative")
d <- matrix(c("a","b","c","d"),
nrow=2, dimnames = list(rownames, colnames))
kable(d,longtable = F, booktabs = F, align="c") %>%
add_header_above(c(" ", "True diagnosis" = 2)) %>%
kable_styling() %>%
column_spec (1:3,border_left = T, border_right = T)
